extern "C" %{

#include "dague.h"

#include "dague_internal.h"
   //#include "data_dist/matrix/two_dim_rectangle_cyclic.h"
#include "data_dist/matrix/matrix.h"
#include "data_dist/matrix/two_dim_tabular.h"
#include "factorize.h"
/* #include "spllt_parsec_data.h" */

#include "spllt_parsec_blk_data.h"

%}

blk            [type = "struct blk_desc*"]
snodes         [type = "void *"]
nnodes         [type = int]
bcs            [type = "void *"]
nbc            [type = int]
diags          [type = "long int *"]
ndiag          [type = int]
min_width_blas [type = int]
val            [type = "void *"]
nval           [type = int]
keep           [type = "void *"]

init_block(id)

   id = 1..nbc

   /* number of update between on current block */
   upd_count = %{ return get_upd_count(bcs, id); %}

   /* current block column*/
   bcol =   %{ return get_bcol(bcs, id); %}
   diag_idx = bcol-1
   /* id of current diag block */
   id_kk  =  %{ return diags[diag_idx]; %}

   isDiag =  %{ return is_diag(bcs, id); %}
   /* id of first block in column */
   blk_sa =  %{ return get_blk_sa(snodes, nnodes, bcs, id); %}
   /* first block column in node */
   bcol_sa =   %{ return get_bcol(bcs, blk_sa); %}
   /* index of diag block on first column within current node */
   diag_idx_sa = bcol_sa-1
   /* id of first diag block */
   id_kk_sa  = %{ return diags[diag_idx_sa]; %}
   /* column index of current block in node */
   id_jk_idx = bcol - bcol_sa
   /* row index of current block in node */
   id_ik_idx = id - id_kk

   : blk(id)

   RW bc <- blk(id)
         -> ((upd_count == 0) && (bcol == bcol_sa) &&  isDiag) ? bc_kk factorize_block(diag_idx)
         -> ((upd_count == 0) && (bcol == bcol_sa) && !isDiag) ? bc_ik solve_block(diag_idx, id)
         -> ((upd_count == 0) && (bcol != bcol_sa)) ? bc_ij update_block(diag_idx_sa, id_kk_sa+id_jk_idx, id_kk_sa+id_jk_idx+id_ik_idx)
         -> (upd_count > 0) ? bc_ij update_between(id, 1) 

BODY
{
   /* printf("[init_blk] blk: %d\n", id); */
   
   spllt_init_blk_c(id, val, nval, keep);
}
END

// factorize block

factorize_block(diag_idx)

   diag_idx = 0..(ndiag-1)
   /* id = 1 */
   id_kk = %{ return diags[diag_idx]; %}
   
   /* id = inline_c %{ return get_blk_sa(snodes, nnodes, bcs, id); %} */
   
   /* get first (diag) block id in current node */
   blk_sa =  %{ return get_blk_sa(snodes, nnodes, bcs, id_kk); %}
   
   last_blk = %{ return get_last_blk(bcs, id_kk); %}

   /* id of prev diag block */
   prev_id_kk = %{ if (diag_idx > 0) {return diags[diag_idx-1];} else {return -1;} %}

   upd_count = %{ return get_upd_count(bcs, id_kk); %}

   /* Number of update_bet task depending on this task */
   dep_out_count = %{ return get_dep_out_count(bcs, id_kk); %}

   : blk(id_kk)

   RW bc_kk <- (id_kk == blk_sa && upd_count == 0) ? bc init_block(id_kk)
            <- (id_kk == blk_sa && upd_count > 0) ? bc_ij update_between(id_kk, upd_count) /* blk(id_kk) */ 
            <- (id_kk != blk_sa) ? bc_ij update_block(diag_idx-1, prev_id_kk+1, prev_id_kk+1) /* blk(id_kk) */
            -> (id_kk == last_blk) ? blk(id_kk) : bc_kk solve_block(diag_idx, (id_kk+1)..last_blk)
            -> (dep_out_count > 0) ? bc update_between_aux(id_kk, 1..dep_out_count) /* blk(id_kk) */

   /* RW bc_kk <- (id == blk_sa) ? blk(id) : bc_ij update_block(prev_diag, 1, id, id) */

BODY
{
   /* printf("[factorize_block] bc_kk: %p\n", bc_kk); */

   int m = get_blk_m(bcs, id_kk);
   int n = get_blk_n(bcs, id_kk);
   
   /* printf("[factorize_block] blk id: %d, m: %d, n: %d\n", id_kk, m, n); */
   /* printf("[factorize_block] diag idx: %ld\n", diags[diag_idx]); */
   /* printf("[factorize_block] bc_kk: %p\n", bc_kk); */

   spllt_factor_diag_block_c(m, n, bc_kk);

}
END

// solve block

solve_block(diag_idx, id_ik)

   diag_idx  = 0..(ndiag-1)
   /* id of current diag block */
   id_kk =  %{ return diags[diag_idx]; %}
   /* id of prev diag block */
   prev_id_kk =  %{ if (diag_idx > 0) {return diags[diag_idx-1];} else {return -1;} %}
   /* id of first block in column */
   blk_sa =  %{ return get_blk_sa(snodes, nnodes, bcs, id_kk); %}
   /* id of last block in column */
   last_blk =  %{ return get_last_blk(bcs, id_kk); %}
   /* iterator on subdiag blocks */
   id_ik = (id_kk+1)..last_blk

   /* number of block column in current node */
   ncol =   %{ return get_nc(snodes, nnodes, bcs, id_kk); %}
   /* current block column*/
   bcol =   %{ return get_bcol(bcs, id_kk); %}
   /* first block column in node */
   bcol_sa =   %{ return get_bcol(bcs, blk_sa); %}
   /* local column index */
   col = bcol - bcol_sa + 1
   /* number of block column to update */
   ncol_upd = ncol - col

   /* idx of ik and ik blocks within current column */
   id_ik_idx = id_ik - id_kk

   upd_count =  %{ return get_upd_count(bcs, id_ik); %}

   /* Number of update_bet task depending on this task */
   dep_out_count =  %{ return get_dep_out_count(bcs, id_ik); %}

   : blk(id_ik)

   READ  bc_kk <- bc_kk factorize_block(diag_idx)
   RW    bc_ik <- (id_kk == blk_sa && upd_count == 0) ? bc init_block(id_ik) /* blk(id_ik) */
               <- (id_kk == blk_sa && upd_count > 0) ? /* blk(id_ik) */ bc_ij update_between(id_ik, upd_count)
               <- (id_kk != blk_sa) ? bc_ij update_block(diag_idx-1, prev_id_kk+1, prev_id_kk+id_ik_idx+1) /* blk(id_ik) */
               -> (col == ncol) ? blk(id_ik)
               -> (col < ncol) ? bc_jk update_block(diag_idx, id_ik, (id_kk+1)..last_blk) /* blk(id_ik) */
               -> (col < ncol) ? bc_ik update_block(diag_idx, (id_kk+1)..(id_kk+ncol_upd), id_ik) /* blk(id_ik) */
               -> (dep_out_count > 0) ? bc update_between_aux(id_ik, 1..dep_out_count) /* blk(id_ik) */
               /* -> blk(id_ik) */

BODY
{
   /* printf("[solve_block] id_kk: %d, id_ik: %d\n", id_kk, id_ik); */

   int m = get_blk_m(bcs, id_ik);
   int n = get_blk_n(bcs, id_ik);

   spllt_solve_block_c(m, n, bc_kk, bc_ik);
}
END

// update block

update_block(diag_idx, id_jk, id_ik)

   diag_idx = 0..(ndiag-1)
   /* id of current diag block */
   id_kk  =  %{ return diags[diag_idx]; %}
   /* get last block id in current block column */
   last_blk =  %{ return get_last_blk(bcs, id_kk); %}
   /* get number of block column in current node */
   ncol =   %{ return get_nc(snodes, nnodes, bcs, id_kk); %}
   /* get column number of diag block */
   bcol_diag =   %{ return get_bcol(bcs, id_kk); %}
   /* get first (diag) block id in current node */
   blk_sa =   %{ return get_blk_sa(snodes, nnodes, bcs, id_kk); %}
   /* get column number of first block in node */
   bcol_sa =   %{ return get_bcol(bcs, blk_sa); %}

   /* number of column to be updated */
   ncol_upd = ncol-(bcol_diag-bcol_sa+1)

   id_jk = (id_kk+1)..(id_kk+ncol_upd)

   id_ik = id_jk..last_blk

   id_ij =  %{ return get_dest_blk_id(bcs, nbc, id_jk, id_ik); %}
   /* get column number of updated block */
   bcol =   %{ return get_bcol(bcs, id_ij); %}

   id_jk_idx = id_jk - id_kk
   id_ik_idx = id_ik - id_kk
   /* id of prev diag block */
   next_id_kk =  %{ if (diag_idx < ndiag) {return diags[diag_idx+1];} else {return -1;} %}
   /* id of prev diag block */
   prev_id_kk =  %{ if (diag_idx > 0) {return diags[diag_idx-1];} else {return -1;} %}

   upd_count =  %{ return get_upd_count(bcs, id_ij); %}

   : blk(id_ij)

   READ bc_jk <- bc_ik solve_block(diag_idx, id_jk)

   READ bc_ik <- bc_ik solve_block(diag_idx, id_ik)

   RW bc_ij <- (id_kk == blk_sa && upd_count == 0) ? bc init_block(id_ij)
            <- (id_kk == blk_sa && upd_count > 0) ? bc_ij update_between(id_ij, upd_count) /* blk(id_ij) */
            <- (id_kk != blk_sa) ? bc_ij update_block(diag_idx-1, prev_id_kk+id_jk_idx+1, prev_id_kk+id_ik_idx+1)
            -> ((bcol == bcol_diag+1) && (id_jk == id_ik)) ? bc_kk factorize_block(diag_idx+1)
            -> ((bcol == bcol_diag+1) && (id_jk != id_ik)) ? bc_ik solve_block(diag_idx+1, next_id_kk+id_ik_idx-1)
            -> (bcol > bcol_diag+1) ? bc_ij update_block(diag_idx+1, next_id_kk+id_jk_idx-1,next_id_kk+id_ik_idx-1)
   /* -> ( (bcol == bcol_diag+1) && !isDiag_ij) ?  */

BODY
{
   /* printf("[update_block] id_kk: %d, id_jk: %d, id_ik: %d, id_ij: %d\n", id_kk, id_jk, id_ik, id_ij); */

   int m = get_blk_m(bcs, id_ij);
   int n = get_blk_n(bcs, id_ij);

   int n1 = get_blk_n(bcs, id_jk);
   
   int diag = is_diag(bcs, id_ij);

   spllt_update_block_c(m, n, bc_ij, diag, n1, bc_jk, bc_ik);

}
END


// update between auxiliary function

update_between_aux(id, i)

  id = 1..nbc

  dep_out_count =  %{ return get_dep_out_count(bcs, id); %}

  i = 1..dep_out_count

  isDiag =  %{ return is_diag(bcs, id); %}
  
  bcol =  %{ return get_bcol(bcs, id); %}
  diag_idx = bcol-1

  /* get information on updated block: idx, position and flow */
  p =  %{ return get_dep_out_p(bcs, id, i); %}
  id_ij =  %{ return get_dep_out_id_ij(bcs, id, i); %}
  flow =  %{ return get_dep_out_flow(bcs, id, i); %}

  : blk(id)

  RW bc <- /* blk(id) */ (isDiag) ? bc_kk factorize_block(diag_idx) : bc_ik solve_block(diag_idx, id)
        -> (flow == 1) ? bc_jk update_between(id_ij, p)
        -> (flow == 2) ? bc_ik update_between(id_ij, p)
      
BODY
{
   /* printf("[update_between_aux] id: %d, i: %d, id_ij: %d, flow: %d, p: %d\n", id, i, id_ij, flow, p); */
}
END

// update between block

update_between(id, i)

  id = 1..nbc
  upd_count =  %{ return get_upd_count(bcs, id); %}
  i = 1..upd_count
  
  bcol =  %{ return get_bcol(bcs, id); %}
  diag_idx = bcol-1

  /* get first (diag) block id in current node */
  blk_sa =   %{ return get_blk_sa(snodes, nnodes, bcs, id); %}
  /* get the first block column in current node */
  bcol_sa =  %{ return get_bcol(bcs, blk_sa); %}
  diag_idx_sa = bcol_sa-1

  /* lkj */
  p1 =  %{ return get_dep_in_p1(bcs, id, i); %}
  id_jk =  %{ return get_dep_in_id_jk(bcs, id, i); %}
  
  /* lij */
  p2 =  %{ return get_dep_in_p2(bcs, id, i); %}
  id_ik =  %{ return get_dep_in_id_ik(bcs, id, i); %}

  /* flow toward update block task */

  /* id of current diag block */
  id_kk  =  %{ return diags[diag_idx]; %}

  /* id of first diag block */
  id_kk_sa  = %{ return diags[diag_idx_sa]; %}

  /* column index of current block in node */
  id_jk_idx = bcol - bcol_sa
  /* row index of current block in node */
  id_ik_idx = id - id_kk

  : blk(id) 

  /* RW bc_ij <- blk(id) */
  /*          -> blk(id) */

  RW bc_ij <- (i == 1) ? bc init_block(id)
           <- (i > 1) ? bc_ij update_between(id, i-1)
           -> (i < upd_count) ? bc_ij update_between(id, i+1)
           -> (i == upd_count && bcol == bcol_sa && id == blk_sa) ? bc_kk factorize_block(diag_idx)
           -> (i == upd_count && bcol == bcol_sa && id != blk_sa) ? bc_ik solve_block(diag_idx, id)
           -> (i == upd_count && bcol != bcol_sa) ? bc_ij update_block(diag_idx_sa, id_kk_sa+id_jk_idx, id_kk_sa+id_jk_idx+id_ik_idx)

  READ bc_jk <- bc update_between_aux(id_jk, p1)

  READ bc_ik <- bc update_between_aux(id_ik, p2)

BODY
{

   int sync = get_dep_in_sync(bcs, id, i);

   /* printf("[update_between] id_ij: %d, id_jk: %d, id_ik: %d, sync: %d\n", id, id_jk, id_ik, sync);    */
   /* printf("[update_between] bcol: %d, bcol_sa: %d\n", bcol, bcol_sa);    */

   
   /* printf("[update_between] bc_ij: %p, bc_jk: %p, bc_ik: %p\n", bc_ij, bc_jk, bc_ik);    */
   /* printf("[update_between] diag_idx: %d\n", diag_idx);    */

   /* printf("[update_between] id: %d, i: %d, upd_count: %d\n", id, i, upd_count);    */
   /* printf("[update_between] id_jk: %d, p1: %d\n", id_jk, p1);    */
   /* printf("[update_between] id_ik: %d, p2: %d\n", id_ik, p2);    */

   if (!sync) {
      
      int m = get_blk_m(bcs, id);
      int n = get_blk_n(bcs, id);

      int dcol = bcol-bcol_sa+1;

      int sbcol = get_bcol(bcs, id_jk);
      int sblk_sa = get_blk_sa(snodes, nnodes, bcs, id_jk);
      int sbcol_sa = get_bcol(bcs, sblk_sa);
      int scol = sbcol - sbcol_sa + 1;

      void *blk = get_blk(bcs, id);

      int n1 = get_blk_n(bcs, id_jk);

      double *src1 = (double *)bc_jk;
      double *src2 = (double *)bc_ik;
      double *dest = (double *)bc_ij;
   
      double *buffer = NULL; // not used for now

      int snode = get_node(bcs, id_jk);

      int csrc = get_dep_in_csrc(bcs, id, i);
      int rsrc = get_dep_in_rsrc(bcs, id, i);


      /* printf("[update_between] csrc: %d, rsrc: %d\n", csrc, rsrc); */
      /* printf("[update_between] dest: %p\n", dest); */

      /* printf("[update_between] dest: %p, src1: %p, src2: %p\n", dest, src1, src2);    */

      spllt_update_between_c(m, n, blk,
                             dcol, snodes, nnodes, n1, scol, snode,
                             dest, src1 + csrc-1, src2 + rsrc-1,
                             /* bc_ij, bc_jk, bc_ik, */
                             buffer, min_width_blas);
   }
}
END


extern "C" %{
   
   dague_handle_t* spllt_parsec_factorize(void *snodes, int nnodes, 
                                          void *bcs, int nbc, 
                                          long int *diags, int ndiag,
                                          int min_width_blas,
                                          void *val, int nval, void *keep) {

      dague_factorize_handle_t* fac_hdl;

      int nodes = 1;
      int rank  = 0;

#ifdef HAVE_MPI
      {
         int provided;
         MPI_Init_thread(NULL, NULL, MPI_THREAD_SERIALIZED, &provided);
      }
      MPI_Comm_size(MPI_COMM_WORLD, &nodes);
      MPI_Comm_rank(MPI_COMM_WORLD, &rank);
#endif
      
      printf("[factorize] nodes: %d, rank: %d\n", nodes, rank);
      printf("[factorize] number of blocks: %d\n", nbc);
      printf("[factorize] number of diag blocks / block columns: %d\n", ndiag);
      
      blk_desc_t *blk_desc = malloc(sizeof(blk_desc_t));
      
      spllt_parsec_blk_data_init(blk_desc,
                                 bcs, nbc,
                                 nodes, rank);
      
      fac_hdl = dague_factorize_new(blk_desc, 
                                    snodes, nnodes, 
                                    bcs, nbc, 
                                    diags, ndiag,
                                    min_width_blas,
                                    val, nval, keep);

      assert( NULL != fac_hdl );

      return &fac_hdl->super;    
   }
%}
