extern "C" %{

#include "dague.h"

#include "dague_internal.h"
   //#include "data_dist/matrix/two_dim_rectangle_cyclic.h"
#include "data_dist/matrix/matrix.h"
#include "data_dist/matrix/two_dim_tabular.h"
#include "factorize.h"
/* #include "spllt_parsec_data.h" */

#include "spllt_parsec_blk_data.h"

%}

blk            [type = "struct blk_desc*"]
snodes         [type = "void *"]
nnodes         [type = int]
bcs            [type = "void *"]
nbc            [type = int]

/* init_blk(id) */

/*    id = 1..nbc */

/*    : blk(id) */
   
/* BODY */
/* { */
/*    /\* printf("[init_blk] blk: %d\n", id); *\/ */
/* } */
/* END */

// factorize block

factorize_block(id, isDiag)

   id = 1..nbc
   /* check existence of this task for this id*/
   isDiag = 1..inline_c %{ return is_diag(bcs, id); %}
   
   last_blk = inline_c %{ return get_last_blk(bcs, id); %}

   : blk(id)

   RW bc_kk <- blk(id)  
            -> (id == last_blk) ? blk(id) : bc_kk solve_block(id, 1, (id+1)..last_blk)
BODY
{
   /* printf("[factorize_block] bc_kk: %p\n", bc_kk); */

   int m = get_blk_m(bcs, id);
   int n = get_blk_n(bcs, id);
   
   printf("[factorize_block] blk id: %d, m: %d, n: %d\n", id, m, n);

   spllt_factor_diag_block_c(m, n, bc_kk);

}
END

// solve block

solve_block(id, isDiag, id_ik)

   id  = 1..nbc
   /* check existence of this task for blk id*/
   isDiag = 1..inline_c %{ return is_diag(bcs, id); %}
   
   last_blk = inline_c %{ return get_last_blk(bcs, id); %}

   /* iterator on subdiag blocks */
   id_ik = (id+1)..last_blk

   /* number of block column in current node */
   ncol =  inline_c %{ return get_nc(snodes, nnodes, bcs, id); %}
   /* current block column*/
   bcol =  inline_c %{ return get_bcol(bcs, id); %}

   : blk(id_ik)

   READ  bc_kk <- bc_kk factorize_block(id, 1)  
   RW    bc_ik <- blk(id_ik)
               -> (bcol == ncol) ? blk(id_ik) 
               -> (bcol < ncol) ? bc_jk update_block(id, isDiag, id_ik, (id+1)..last_blk)
               -> (bcol < ncol) ? bc_ik update_block(id, isDiag, (id+1)..(id+ncol), id_ik)

BODY
{
   printf("[solve_block] id: %d, id_ik: %d\n", id, id_ik);

   int m = get_blk_m(bcs, id_ik);
   int n = get_blk_n(bcs, id_ik);

   spllt_solve_block_c(m, n, bc_kk, bc_ik);
}
END

// update block

update_block(id, isDiag, id_jk, id_ik)

   id  = 1..nbc
   /* check existence of this task for blk id*/
   isDiag = 1..inline_c %{ return is_diag(bcs, id); %}
   /* get last block id in current block column */
   last_blk = inline_c %{ return get_last_blk(bcs, id); %}
   /* get number of block column in current node */
   ncol =  inline_c %{ return get_nc(snodes, nnodes, bcs, id); %}

   /* get first (diag) block id in current node */
   blk_sa =  inline_c %{ return get_blk_sa(snodes, nnodes, bcs, id); %}
   /* id of previous diag block*/
   prev_diag = inline_c %{ return get_prev_dblk(bcs, id); %}

   next_diag = inline_c %{ return get_next_dblk(bcs, id); %}

   id_jk = (id+1)..(id+ncol)

   id_ik = id_jk..last_blk

   id_ij = inline_c %{ return get_dest_blk_id(bcs, nbc, id_jk, id_ik); %}

   : blk(id_ij)

   READ bc_jk <- bc_ik solve_block(id, 1, id_jk)

   READ bc_ik <- bc_ik solve_block(id, 1, id_ik)

   RW bc_ij <- (id == blk_sa) ? blk(id_ij) : bc_ij update_block(id, isDiag, id_jk, id_ik) 
            -> blk(id_ij)

BODY
{
   printf("[update_block] id: %d, id_jk: %d, id_ij: %d\, id_ik: %d\n", id, id_jk, id_ik, id_ij);

   /* int m = get_blk_m(bcs, id_ik); */
   /* int n = get_blk_n(bcs, id_ik); */

}
END


extern "C" %{
   
   dague_handle_t* spllt_parsec_factorize(void *snodes, int nnodes, 
                                          void *bcs, int nbc) {

      dague_factorize_handle_t* fac_hdl;

      int nodes = 1;
      int rank  = 0;

#ifdef HAVE_MPI
      {
         int provided;
         MPI_Init_thread(NULL, NULL, MPI_THREAD_SERIALIZED, &provided);
      }
      MPI_Comm_size(MPI_COMM_WORLD, &nodes);
      MPI_Comm_rank(MPI_COMM_WORLD, &rank);
#endif
      
      printf("[factorize] nodes: %d, rank: %d\n", nodes, rank);
      printf("[factorize] number of blocks: %d\n", nbc);
      
      blk_desc_t *blk_desc = malloc(sizeof(blk_desc_t));
      
      spllt_parsec_blk_data_init(blk_desc,
                                 bcs, nbc,
                                 nodes, rank);
      
      fac_hdl = dague_factorize_new(blk_desc, snodes, nnodes, bcs, nbc);

      assert( NULL != fac_hdl );

      return &fac_hdl->super;    
   }
%}
