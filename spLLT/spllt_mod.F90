module spllt_mod
  use hsl_ma87_double, only: block_type 
  use hsl_zd11_double
#if defined(SPLLT_USE_STARPU)
  use iso_c_binding
  use starpu_f_mod
#endif
  implicit none

  ! type :: matrix_type
  !    integer :: n, ne
  !    integer, dimension(:), allocatable :: ptr, row, col
  !    real(wp), dimension(:), allocatable :: val
  ! end type matrix_type

  integer, parameter :: wp = kind(0d0)
#if defined(SPLLT_USE_STARPU)
  integer, parameter :: long = c_long
#else
  integer, parameter :: long = selected_int_kind(18)
#endif

  real(wp), parameter :: one = 1.0_wp
  real(wp), parameter :: zero = 0.0_wp

  ! error flags
  integer, parameter :: spllt_success           = 0 
  integer, parameter :: spllt_error_allocation  = -1
  integer, parameter :: spllt_error_unknown     = -99 

  ! Default values
  ! node amalgamation parameter
  integer, parameter :: spllt_nemin_default = 32
  ! Block size with dense kernel
  integer, parameter :: spllt_nb_default = 256

  type spllt_cntl
     integer :: ncpu = 1 ! number of CPU workers
     integer :: nb   = 16 ! blocking size
     integer :: nemin = 32 ! node amalgamation parameter
  end type spllt_cntl
  
  type spllt_bc_type
     type(block_type), pointer :: blk ! pointer to the block in keep
     real(wp), pointer :: c(:)
#if defined(SPLLT_USE_STARPU)
     type(c_ptr)    :: hdl  ! StarPU handle
#endif
     integer :: mem_node = 0 ! memory node where the block is allocated
  end type spllt_bc_type
  
  ! problem data (analyis)
  type spllt_adata_type
     integer(long) :: num_factor = 0_long ! Number of entries in the factor.
     integer(long) :: num_flops = 0_long  ! Number of flops for factor.
     ! weight(i): weight of the subtree rooted at node i where weight
     ! corresponds to the number of flops
     real(kind(1.d0)), allocatable :: weight(:)
  end type spllt_adata_type

  ! problem data
  type spllt_data_type
     type(spllt_bc_type), allocatable :: bc(:) ! blocks
     type(spllt_bc_type) :: workspace ! workspaces
  end type spllt_data_type

  interface gen_random_posdef
     module procedure gen_random_posdef
  end interface gen_random_posdef

  interface spllt_bwerr
     module procedure spllt_bwerr_1d
  end interface spllt_bwerr

  type spllt_options
     integer :: ncpu = 1 ! number of CPU workers
     integer :: nb   = 16 ! blocking size
     character(len=100) :: mat = ''
     integer :: nemin = -1
  end type spllt_options

contains

  ! subroutine spllt_realloc_1d(a, n)
  !   implicit none

  !   if (.not. allocated(a)) then
  !      allocate(a(n))
  !      return
  !   else
  !      if (size(a) .lt. n) then
  !         deallocate(a)
  !         allocate(a(n))
  !      end if
  !   end if
    
  !   return
  ! end subroutine spllt_realloc_1d

  subroutine spllt_print_atree(keep)
    use hsl_ma87_double
    implicit none    

    type(MA87_keep), target, intent(in) :: keep

    integer :: snode, num_nodes
    type(node_type), pointer     :: node ! node in the atree
    integer :: m, n

    num_nodes = keep%info%num_nodes

    open(2, file="atree.dot")

    write(2, '("graph atree {")')
    write(2, '("node [")')
    write(2, '("style=filled")')
    write(2, '("]")')
    
    do snode=1,num_nodes

       node => keep%nodes(snode)
       m = size(node%index)
       n = node%en - node%sa + 1

       write(2, '(i10)', advance="no")snode
       write(2, '(" ")', advance="no")
       write(2, '("[")', advance="no")
       write(2, '("fillcolor=white ")', advance="no")
       write(2, '("label=""")', advance="no")  
       write(2, '("node:", i5,"\n")', advance="no")snode
       write(2, '("m:", i5,"\n")', advance="no")m
       write(2, '("n:", i5,"\n")', advance="no")n
       write(2, '("""")', advance="no")         
       write(2, '("]")', advance="no")
       write(2, '(" ")')

       if(keep%nodes(snode)%parent .ne. -1) write(2, '(i10, "--", i10)')keep%nodes(snode)%parent, snode
    end do

    write(2, '("}")')

    close(2)
    
    return
  end subroutine spllt_print_atree
  
  subroutine gen_random_posdef(matrix, nza, iseed)
    implicit none
    type(zd11_type), intent(inout) :: matrix
    integer, intent(in) :: nza
    integer, intent(inout) :: iseed

    integer, dimension(10) :: icntl
    character(len=8) :: key
    integer, dimension(:), allocatable :: work
    integer :: i, j, k
    real(wp) :: tempv

    ! Setup stuff for ym11
    key = 'nothing '
    call ym11id(icntl, i)
    icntl(3) = 0 ! Symmetric
    allocate(work(2*matrix%n))

    ! Generate matrix
    call ym11ad(matrix%n, matrix%n, nza, matrix%ne, matrix%row, &
         matrix%val, matrix%ptr, work, icntl, key, iseed)

    ! Make matrix diagonally dominant, observing first entry in column
    ! is always the diagonal when matrix generated by ym11
    do k = 1, matrix%n
       tempv = zero
       do j = matrix%ptr(k)+1, matrix%ptr(k+1)-1
          tempv = tempv + abs(matrix%val(j))
          i = matrix%ptr(matrix%row(j))
          matrix%val(i) = matrix%val(i) + abs(matrix%val(j))
       end do
       i = matrix%ptr(k)
       matrix%val(i) = one + matrix%val(i) + tempv
    end do
  end subroutine gen_random_posdef

  subroutine spllt_bwerr_1d(a,x,b,res)

    type(zd11_type), intent(in) :: a
    real(wp), dimension(:), allocatable :: x, b
    real(wp) :: res

    integer :: i, j, k
    real(wp), dimension(:), allocatable :: work, r
    real(wp) :: anorm, atemp, bnorm, xnorm

    allocate(work(a%n), r(a%n))

    anorm = zero
    bnorm = zero
    xnorm = zero
    work = zero
    
    r = b
    do k = 1, a%n
       do j = a%ptr(k), a%ptr(k+1)-1
          i = a%row(j)
          
          atemp = a%val(j)
          r(i) = r(i) - x(k)*atemp 
          work(k) = work(k) + abs(atemp)
          if(i.eq.k) cycle
          r(k) = r(k) - x(i)*atemp 
          work(i) = work(i) + abs(atemp)
       end do
    end do

    anorm = maxval(abs(work))
    bnorm = maxval(abs(b))
    xnorm = maxval(abs(x))
    res   = maxval(abs(r))

    res = res/(anorm*xnorm + bnorm)

  end subroutine spllt_bwerr_1d
  
  subroutine compute_resid(nrhs,a,x,lx,rhs,lrhs,res)

    integer, intent(in) :: nrhs, lrhs, lx
    type(zd11_type), intent(in) :: a
    real(wp), intent(in) :: rhs(lrhs,nrhs)
    real(wp), intent(in) :: x(lx,nrhs)
    real(wp), dimension(:,:), allocatable, intent(inout) :: res
    real(wp), dimension(:), allocatable :: work

    integer :: i, j, k
    real(wp) :: anorm, atemp, bnorm(1:nrhs), xnorm(1:nrhs)

    if (allocated(res)) deallocate(res)
    allocate(res(a%n,nrhs),work(a%n))

    anorm = zero
    bnorm = zero
    xnorm = zero
    work = zero

    ! Check residual
    res(1:a%n,1:nrhs) = rhs(1:a%n,1:nrhs)
    do k = 1, a%n
       do j = a%ptr(k), a%ptr(k+1)-1
          i = a%row(j)
          atemp = a%val(j)
          res(i, 1:nrhs) = res(i, 1:nrhs) - atemp*x(k,1:nrhs)
          work(i) = work(i) + abs(atemp)
          if(i.eq.k) cycle
          res(k, 1:nrhs) = res(k, 1:nrhs) - atemp*x(i,1:nrhs)
          work(k) = work(k) + abs(atemp)
       end do
    end do

    do k = 1, a%n
       anorm = max(anorm,work(k))
       do i = 1,nrhs
          bnorm(i) = max(bnorm(i),abs(rhs(k,i)))
          xnorm(i) = max(xnorm(i),abs(x(k,i)))
       end do
    end do

    do k = 1,a%n
       do i = 1,nrhs
          res(k,i) = res(k,i)/(anorm*xnorm(i) + bnorm(i))
       end do
    end do

  end subroutine compute_resid

  subroutine spllt_print_err(iflag, control, context, st)
    use hsl_ma87_double
    implicit none
    
    integer, intent(in) :: iflag
    type(ma87_control), intent(in) :: control
    character (len=*), optional, intent(in) :: context
    integer, intent(in), optional :: st

    select case(iflag)
    case(spllt_error_allocation)
       write(*,*) 'allocation error'
    case default
       write(*,*) 'unknown error'
    end select

    return
  end subroutine spllt_print_err

  subroutine amd_order(a,order)
    type(zd11_type), intent(in) :: a
    integer, dimension(:), allocatable :: order

    logical :: realloc_flag
    integer :: i, st
    integer, dimension(10) :: icntl, info
    real(wp), dimension(10) :: rinfo
    integer, dimension(:), allocatable :: work, ptr

    realloc_flag = .true.
    if(allocated(order)) realloc_flag = size(order).lt.a%n

    if(realloc_flag) then
       deallocate(order,stat=st)
       allocate(order(a%n))
    endif

    ! Initilise control
    call mc47id(icntl)
    icntl(1:2) = -1 ! Supress warnings and errors
    icntl(5) = huge(0) ! Largest integer

    ! Copy ptr data to work array
    allocate(ptr(a%n+1))
    ptr(:) = a%ptr(1:a%n+1)
    ! Copy row data to work array
    allocate(work(2*a%ptr(a%n+1) + 10*a%n))
    work(1:a%ptr(a%n+1)-1) = &
         a%row(1:a%ptr(a%n+1)-1)

    ! Perform AMD
    call mc47ad(a%n, a%ptr(a%n+1)-1, ptr, work, &
         size(work), icntl, info, rinfo)
    if(info(1).lt.0) then
       ! Failed for some reason
       do i = 1, a%n
          order(i) = i
       end do
       return
    endif

    ! Extract ordering
    order(1:a%n) = work(size(work)-a%n+1:size(work))

  end subroutine amd_order

  subroutine splllt_parse_args(options)
    implicit none

    type(spllt_options), intent(inout) :: options
    
    integer :: argnum, narg
    character(len=200) :: argval

    narg = command_argument_count()
    argnum = 1
    do while(argnum <= narg)
       call get_command_argument(argnum, argval)
       argnum = argnum + 1
       select case(argval)
       case("--nb")
          call get_command_argument(argnum, argval)
          argnum = argnum + 1
          read( argval, * ) options%nb
       case("--ncpu")
          call get_command_argument(argnum, argval)
          argnum = argnum + 1
          read( argval, * ) options%ncpu
       case("--mat")
          call get_command_argument(argnum, argval)
          argnum = argnum + 1
          read( argval, * ) options%mat
       case("--nemin")
          call get_command_argument(argnum, argval)
          argnum = argnum + 1
          read( argval, * ) options%nemin
       case default
          write(*,'("Unrecognised command line argument: ", a20)'), argval
       end select
    end do

  end subroutine splllt_parse_args

end module spllt_mod
