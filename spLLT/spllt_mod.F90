module spllt_mod
  use hsl_zd11_double
  implicit none

  ! type :: matrix_type
  !    integer :: n, ne
  !    integer, dimension(:), allocatable :: ptr, row, col
  !    real(wp), dimension(:), allocatable :: val
  ! end type matrix_type

  integer, parameter :: wp = kind(0d0)
  integer, parameter :: long = selected_int_kind(18)

  real(wp), parameter :: one = 1.0_wp
  real(wp), parameter :: zero = 0.0_wp

  ! error flags
  integer, parameter :: spllt_success           = 0 
  integer, parameter :: spllt_error_allocation  = -1
  integer, parameter :: spllt_error_unknown     = -99 

  interface gen_random_posdef
     module procedure gen_random_posdef
  end interface gen_random_posdef

  interface spllt_bwerr
     module procedure spllt_bwerr_1d
  end interface spllt_bwerr

contains

  ! subroutine spllt_realloc_1d(a, n)
  !   implicit none

  !   if (.not. allocated(a)) then
  !      allocate(a(n))
  !      return
  !   else
  !      if (size(a) .lt. n) then
  !         deallocate(a)
  !         allocate(a(n))
  !      end if
  !   end if
    
  !   return
  ! end subroutine spllt_realloc_1d

  subroutine spllt_print_atree(keep)
    use hsl_ma87_double
    implicit none    

    type(MA87_keep), intent(in) :: keep

    integer :: snode, num_nodes

    num_nodes = keep%info%num_nodes

    open(2, file="atree.dot")

    write(2, '("graph atree {")')
    
    do snode=1,num_nodes
       write(2, '(i10)')snode
       if(keep%nodes(snode)%parent .ne. -1) write(2, '(i10, "--", i10)')keep%nodes(snode)%parent, snode
    end do

    write(2, '("}")')

    close(2)
    
    return
  end subroutine spllt_print_atree
  
  subroutine gen_random_posdef(matrix, nza, iseed)
    implicit none
    type(zd11_type), intent(inout) :: matrix
    integer, intent(in) :: nza
    integer, intent(inout) :: iseed

    integer, dimension(10) :: icntl
    character(len=8) :: key
    integer, dimension(:), allocatable :: work
    integer :: i, j, k
    real(wp) :: tempv

    ! Setup stuff for ym11
    key = 'nothing '
    call ym11id(icntl, i)
    icntl(3) = 0 ! Symmetric
    allocate(work(2*matrix%n))

    ! Generate matrix
    call ym11ad(matrix%n, matrix%n, nza, matrix%ne, matrix%row, &
         matrix%val, matrix%ptr, work, icntl, key, iseed)

    ! Make matrix diagonally dominant, observing first entry in column
    ! is always the diagonal when matrix generated by ym11
    do k = 1, matrix%n
       tempv = zero
       do j = matrix%ptr(k)+1, matrix%ptr(k+1)-1
          tempv = tempv + abs(matrix%val(j))
          i = matrix%ptr(matrix%row(j))
          matrix%val(i) = matrix%val(i) + abs(matrix%val(j))
       end do
       i = matrix%ptr(k)
       matrix%val(i) = one + matrix%val(i) + tempv
    end do
  end subroutine gen_random_posdef

  subroutine spllt_bwerr_1d(a,x,b,res)

    type(zd11_type), intent(in) :: a
    real(wp), dimension(:), allocatable :: x, b
    real(wp) :: res

    integer :: i, j, k
    real(wp), dimension(:), allocatable :: work, r
    real(wp) :: anorm, atemp, bnorm, xnorm

    allocate(work(a%n), r(a%n))

    anorm = zero
    bnorm = zero
    xnorm = zero
    work = zero
    
    r = b
    do k = 1, a%n
       do j = a%ptr(k), a%ptr(k+1)-1
          i = a%row(j)
          
          atemp = a%val(j)
          r(i) = r(i) - x(k)*atemp 
          work(k) = work(k) + abs(atemp)
          if(i.eq.k) cycle
          r(k) = r(k) - x(i)*atemp 
          work(i) = work(i) + abs(atemp)
       end do
    end do

    anorm = maxval(abs(work))
    bnorm = maxval(abs(b))
    xnorm = maxval(abs(x))
    res   = maxval(abs(r))

    res = res/(anorm*xnorm + bnorm)

  end subroutine spllt_bwerr_1d
  
  subroutine compute_resid(nrhs,a,x,lx,rhs,lrhs,res)

    integer, intent(in) :: nrhs, lrhs, lx
    type(zd11_type), intent(in) :: a
    real(wp), intent(in) :: rhs(lrhs,nrhs)
    real(wp), intent(in) :: x(lx,nrhs)
    real(wp), dimension(:,:), allocatable, intent(inout) :: res
    real(wp), dimension(:), allocatable :: work

    integer :: i, j, k
    real(wp) :: anorm, atemp, bnorm(1:nrhs), xnorm(1:nrhs)

    if (allocated(res)) deallocate(res)
    allocate(res(a%n,nrhs),work(a%n))

    anorm = zero
    bnorm = zero
    xnorm = zero
    work = zero

    ! Check residual
    res(1:a%n,1:nrhs) = rhs(1:a%n,1:nrhs)
    do k = 1, a%n
       do j = a%ptr(k), a%ptr(k+1)-1
          i = a%row(j)
          atemp = a%val(j)
          res(i, 1:nrhs) = res(i, 1:nrhs) - atemp*x(k,1:nrhs)
          work(i) = work(i) + abs(atemp)
          if(i.eq.k) cycle
          res(k, 1:nrhs) = res(k, 1:nrhs) - atemp*x(i,1:nrhs)
          work(k) = work(k) + abs(atemp)
       end do
    end do

    do k = 1, a%n
       anorm = max(anorm,work(k))
       do i = 1,nrhs
          bnorm(i) = max(bnorm(i),abs(rhs(k,i)))
          xnorm(i) = max(xnorm(i),abs(x(k,i)))
       end do
    end do

    do k = 1,a%n
       do i = 1,nrhs
          res(k,i) = res(k,i)/(anorm*xnorm(i) + bnorm(i))
       end do
    end do

  end subroutine compute_resid

  subroutine spllt_print_err(iflag, control, context, st)
    use hsl_ma87_double
    implicit none
    
    integer, intent(in) :: iflag
    type(ma87_control), intent(in) :: control
    character (len=*), optional, intent(in) :: context
    integer, intent(in), optional :: st

    select case(iflag)
    case(spllt_error_allocation)
       write(*,*) 'allocation error'
    case default
       write(*,*) 'unknown error'
    end select

    return
  end subroutine spllt_print_err

end module spllt_mod
