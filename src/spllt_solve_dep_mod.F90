module spllt_solve_dep_mod

  use spllt_data_mod

contains

  subroutine spllt_compute_blk_solve_dep(fkeep, blk)
    type(spllt_fkeep), target, intent(inout)  :: fkeep
    integer, intent(in)                       :: blk

    call fwd_update_dependency(fkeep, blk, fkeep%bc(blk)%fwd_update_dep)
    fkeep%bc(blk)%fwd_solve_dep   = fwd_solve_dependency(fkeep, blk)

    fkeep%bc(blk)%bwd_update_dep  = bwd_update_dependency(fkeep, blk)
    call bwd_solve_dependency(fkeep, blk, fkeep%bc(blk)%bwd_solve_dep)

  end subroutine spllt_compute_blk_solve_dep

  subroutine spllt_compute_solve_dep(fkeep)
    type(spllt_fkeep), target, intent(inout)  :: fkeep

    integer :: i
    do i = 1, fkeep%nodes(fkeep%info%num_nodes)%blk_en
      call spllt_compute_blk_solve_dep(fkeep, i)
    end do
  end subroutine spllt_compute_solve_dep

  !Return the position in child_node of the rows of node that are 
  ! in child_node
  subroutine get_update_dep(fkeep, child_node, node, pos)
    
    type(spllt_fkeep), target, intent(in) :: fkeep
    integer, intent(in)                   :: child_node
    integer, intent(in)                   :: node
    integer, allocatable, intent(out)     :: pos(:)

    integer :: node_index
    integer :: child_node_index
    integer :: i, j, k
    integer, pointer, dimension(:) :: p_node_index, p_child_node_index

    p_node_index        => fkeep%nodes(node)%index
    p_child_node_index  => fkeep%nodes(child_node)%index


    i = 1
    j = 1
    k = 1
    do while(j .le. size(p_node_index) .and. k .le. size(p_child_node_index))
      if(p_node_index(j) .lt. p_child_node_index(k)) then
        j = j + 1
      else if(p_node_index(j) .gt. p_child_node_index(k)) then
        k = k + 1
      else
        i = i + 1
        j = j + 1
        k = k + 1
      end if
    end do

    allocate(pos(i - 1))

    if( i .eq. 1 )then
      return
    end if

    !Reiterate to copy the position into pos
    i = 1
    j = 1
    k = 1
    do while(j .le. size(p_node_index) .and. k .le. size(p_child_node_index))
      if(p_node_index(j) .lt. p_child_node_index(k)) then
        j = j + 1
      else if(p_node_index(j) .gt. p_child_node_index(k)) then
        k = k + 1
      else
        pos(i) = j
        i = i + 1
        j = j + 1
        k = k + 1
      end if
    end do

  end subroutine get_update_dep

  subroutine get_update_nblk(fkeep, child_node, blk_index, nblk)
    type(spllt_fkeep), target, intent(in) :: fkeep
    integer, intent(in)                   :: child_node
    integer, intent(inout)                :: blk_index(:)
    integer, intent(out)                  :: nblk

    integer :: child_node_index
    integer :: i, j, k
    integer, pointer :: p_child_node_index(:)
    integer :: cur_blk_dep, tmp

    p_child_node_index  => fkeep%nodes(child_node)%index
    cur_blk_dep = 0 !Impossible value but used as initialization

    nblk  = 0
    j     = 1
    k     = 1
    do while(j .le. size(blk_index) .and. k .le. size(p_child_node_index))
      if(blk_index(j) .lt. p_child_node_index(k)) then
        j = j + 1
      else if(blk_index(j) .gt. p_child_node_index(k)) then
        k = k + 1
      else

        tmp = get_child_dep_blk_id(fkeep, child_node, k, &
          size(p_child_node_index))

        if(cur_blk_dep .lt. tmp) then
          cur_blk_dep = tmp
          nblk = nblk + 1
        end if
        j = j + 1
        k = k + 1
      end if
    end do

  end subroutine get_update_nblk

  subroutine get_update_dep_blk(fkeep, child_node, blk_index, pos)
    type(spllt_fkeep), target, intent(in) :: fkeep
    integer, intent(in)                   :: child_node
    integer, intent(inout)                :: blk_index(:)
    integer, intent(out)                  :: pos(:)

    integer :: child_node_index
    integer :: i, j, k
    integer :: nb
    integer, pointer :: p_child_node_index(:)
    integer :: cur_blk_dep, tmp
    integer :: lblk, nlblk, diff

    p_child_node_index  => fkeep%nodes(child_node)%index
    nb = fkeep%nodes(child_node)%nb
    cur_blk_dep = 0 !Impossible value but used as initialization

    !Set variables
    cur_blk_dep = 0
    i           = 1
    j           = 1
    k           = 1
    do while(j .le. size(blk_index) .and. k .le. size(p_child_node_index))
      if(blk_index(j) .lt. p_child_node_index(k)) then
        j = j + 1
      else if(blk_index(j) .gt. p_child_node_index(k)) then
        k = k + 1
      else
        
        tmp = get_child_dep_blk_id(fkeep, child_node, k, &
          size(p_child_node_index))

        if(cur_blk_dep .lt. tmp) then
          cur_blk_dep = tmp
          pos(i) = tmp
          i = i + 1
        end if
        j = j + 1
        k = k + 1
      end if
    end do

  end subroutine get_update_dep_blk

  function get_child_dep_blk_id(fkeep, child_node, row, nrow)
    integer                               :: get_child_dep_blk_id
    type(spllt_fkeep), target, intent(in) :: fkeep
    integer, intent(in)                   :: child_node
    integer, intent(in)                   :: row
    integer, intent(in)                   :: nrow

    integer :: lblk, nlblk, diff, tmp, nb

    nb    = fkeep%nodes(child_node)%nb
    tmp   = fkeep%nodes(child_node)%blk_sa
    lblk  = ceiling((row + 0.0) / nb)
    nlblk = ceiling((nrow + 0.0)/nb)
    diff  = (fkeep%nodes(child_node)%blk_en - &
      fkeep%bc(fkeep%nodes(child_node)%blk_en)%dblk + 0) ! #blk on the last nbol
    if(lblk .le. (nlblk - diff)) then
      tmp = tmp + (lblk - 1) * ( nlblk + 1 - 0.5 * lblk )
    else
      tmp = fkeep%bc(fkeep%nodes(child_node)%blk_en)%dblk + lblk - &
        (nlblk - diff) - 0
    end if

    get_child_dep_blk_id = tmp

  end function get_child_dep_blk_id

  subroutine reduce_ind_and_get_ndep(fkeep, ind, nind, child_node, ndep)
    type(spllt_fkeep), target, intent(in) :: fkeep
    integer, intent(inout)                :: ind(:)
    integer, intent(inout)                :: nind       ! #elmt in ind
    integer, intent(in)                   :: child_node
    integer, intent(out)                  :: ndep       ! #block dep

    integer :: i, j, k
    integer :: nb, nval
    integer, pointer :: p_child_node_index(:)
    integer :: cur_blk_dep, tmp
    integer :: lblk, nlblk, diff
    integer, pointer :: p_child_blk_index(:)

    p_child_node_index  => fkeep%nodes(child_node)%index
    nb                  = fkeep%nodes(child_node)%nb
    cur_blk_dep         = 0 !Impossible value but used as initialization
    ndep                = 0

    !Set variables
    cur_blk_dep = 0
    i           = 1
    j           = 1
    k           = 1
    nval        = 0
    do while(j .le. nind .and. k .le. size(p_child_node_index))
      if(ind(j) .lt. p_child_node_index(k)) then
        nval = nval + 1
        ind(nval) = ind(j)
        j = j + 1
      else if(ind(j) .gt. p_child_node_index(k)) then
        k = k + 1
      else
        
        tmp = get_child_dep_blk_id(fkeep, child_node, k, &
          size(p_child_node_index))

        
        if(cur_blk_dep .lt. tmp) then
!         print *, "Dep with blk ", tmp
          cur_blk_dep = tmp
          ndep = ndep + 1
          i = i + 1
        end if
        j = j + 1
        k = k + 1
      end if
    end do

    if(j .lt. nind) then
      nval = nval + 1
      ind(nval: nval + nind - j) = ind(j : nind)
      nind = nval + nind - j
    else 
      nind = nval
    end if


  end subroutine reduce_ind_and_get_ndep

  recursive subroutine getUpdateNDep(fkeep, node, ind, nind, ndep, lvl)
    type(spllt_fkeep), intent(in) :: fkeep
    integer, intent(in)           :: node
    integer, intent(inout)        :: ind(:)
    integer, intent(inout)        :: nind
    integer, intent(inout)        :: ndep(:)
    integer, intent(in), optional :: lvl

    integer :: child, dep, nldep, offset, i, nsubind, nchild
    integer, allocatable :: subind(:)
    integer :: rlvl

    if(present(lvl)) then
      rlvl = lvl
    else
      rlvl = 1
    end if

    nchild = fkeep%nodes(node)%nchild

    if(nind .eq. 0) then
      ndep(1) = 0
      return
    end if

    if(nchild .eq. 0) then
      return
    end if

    offset = nchild + 1
    allocate(subind(nind))

    do i = 1, nchild
      child = fkeep%nodes(node)%child(i)
      nldep = 0

      subind = ind
      nsubind = nind

      call reduce_ind_and_get_ndep(fkeep, subind, nsubind, child, nldep)
      ndep(i) = nldep

      if(fkeep%nodes(child)%nchild .gt. 0) then

        call getUpdateNDep(fkeep, child, subind, nsubind, ndep(offset :       &
          offset + child - fkeep%nodes(child)%least_desc - 1), &
          rlvl + 1)

        offset = offset + fkeep%nodes(child)%nchild
      end if
    end do

    deallocate(subind)

  end subroutine getUpdateNDep

  !Get the dependencies after counting its number
  subroutine reduce_ind_and_get_dep(fkeep, ind, nind, child_node, dep)
    type(spllt_fkeep), target, intent(in) :: fkeep
    integer, intent(inout)                :: ind(:)
    integer, intent(inout)                :: nind       ! #elmt in ind
    integer, intent(in)                   :: child_node
    integer, intent(out)                  :: dep(:)     ! List of block dep

    integer :: i, j, k
    integer :: nb, nval
    integer, pointer :: p_child_node_index(:)
    integer :: cur_blk_dep, tmp
    integer :: lblk, nlblk, diff, ndep

    p_child_node_index  => fkeep%nodes(child_node)%index
    nb                  = fkeep%nodes(child_node)%nb
    cur_blk_dep         = 0 !Impossible value but used as initialization
    ndep                = 1

    !Set variables
    cur_blk_dep = 0
    i           = 1
    j           = 1
    k           = 1
    nval        = 0
    do while(j .le. nind .and. k .le. size(p_child_node_index))
      if(ind(j) .lt. p_child_node_index(k)) then
        nval = nval + 1
        ind(nval) = ind(j)
        j = j + 1
      else if(ind(j) .gt. p_child_node_index(k)) then
        k = k + 1
      else
        
        tmp = get_child_dep_blk_id(fkeep, child_node, k, &
          size(p_child_node_index))
        
        if(cur_blk_dep .lt. tmp) then
!         print *, "Dep with blk ", tmp
          cur_blk_dep = tmp
          dep(ndep) = tmp
          ndep = ndep + 1
          i = i + 1
        end if
        j = j + 1
        k = k + 1
      end if
    end do

    if(j .lt. nind) then
      nval = nval + 1
      ind(nval: nval + nind - j) = ind(j : nind)
      nind = nval + nind - j
    else 
      nind = nval
    end if


  end subroutine reduce_ind_and_get_dep

  recursive subroutine getUpdateDep(fkeep, node, ind, nind, dep, ndep, lvl)
    type(spllt_fkeep), intent(in) :: fkeep
    integer, intent(in)           :: node
    integer, intent(inout)        :: ind(:)
    integer, intent(inout)        :: nind
    integer, intent(inout)        :: dep(:)
    integer, intent(in)           :: ndep(:)
    integer, intent(in), optional :: lvl

    integer :: child, nldep, offset, i, nsubind, nchild
    integer, allocatable :: subind(:)
    integer :: rlvl

    if(present(lvl)) then
      rlvl = lvl
    else
      rlvl = 1
    end if

    nchild = fkeep%nodes(node)%nchild

    if(nind .eq. 0) then
      return
    end if

    if(nchild .eq. 0) then
      return
    end if

    offset = nchild + 1
    allocate(subind(nind))

    do i = 1, nchild
      child = fkeep%nodes(node)%child(i)
      nldep = 0

      subind = ind
      nsubind = nind

      if(ndep(i+1) .gt. ndep(i)) then

        call reduce_ind_and_get_dep(fkeep, subind, nsubind, child, &
          dep(ndep(i) : ndep(i + 1) - 1))

        if(fkeep%nodes(child)%nchild .gt. 0) then
          
          nldep = ndep(offset + child - fkeep%nodes(child)%least_desc ) - &
            ndep(offset)

          if(nldep .gt. 0) then
            call getUpdateDep(fkeep, child, subind, nsubind,      &
              dep(ndep(offset)  : ndep(offset) + nldep - 1),      &
              ndep(ndep(offset) : ndep(offset) + nldep - 1),      &
              rlvl + 1)

            offset = offset + nldep
          end if
        end if
      end if
    end do

    deallocate(subind)

  end subroutine getUpdateDep

  subroutine reduce_ind_and_get_dep_blk(fkeep, ind, nind, child_node, blk_dep)
    type(spllt_fkeep), target, intent(in) :: fkeep
    integer, intent(inout)                :: ind(:)
    integer, intent(inout)                :: nind       ! #elmt in ind
    integer, intent(in)                   :: child_node
    integer, intent(out)                  :: blk_dep(:) ! Dep of the block

    integer :: i, j, k
    integer :: nb, nval
    integer, pointer :: p_child_node_index(:)
    integer :: cur_blk_dep, tmp
    integer :: lblk, nlblk, diff

    p_child_node_index  => fkeep%nodes(child_node)%index
    nb = fkeep%nodes(child_node)%nb
    cur_blk_dep = 0 !Impossible value but used as initialization

    !Set variables
    cur_blk_dep = 0
    i           = 1
    j           = 1
    k           = 1
    nval        = 0
    do while(j .le. nind .and. k .le. size(p_child_node_index))
      if(ind(j) .lt. p_child_node_index(k)) then
        nval = nval + 1
        ind(nval) = ind(j)
        j = j + 1
      else if(ind(j) .gt. p_child_node_index(k)) then
        k = k + 1
      else
        
        tmp = get_child_dep_blk_id(fkeep, child_node, k, &
          size(p_child_node_index))
        
        if(cur_blk_dep .lt. tmp) then
          cur_blk_dep = tmp
          blk_dep(i) = tmp
          i = i + 1
        end if
        j = j + 1
        k = k + 1
      end if
    end do

    if(j .lt. nind) then
      nval = nval + 1
      ind(nval: nval + nind - j) = ind(j : nind)
      nind = nval + nind - j
    else 
      nind = nval
    end if

  end subroutine reduce_ind_and_get_dep_blk

  subroutine getPointerBlkIndex(fkeep, blk, p)
    type(spllt_fkeep), target, intent(in) :: fkeep
    integer, intent(in)                   :: blk
    integer, pointer, intent(out)         :: p(:)

    integer :: node        
    integer :: nb          
    integer :: blkm        
    integer :: blk_sa      
    integer :: bcol_blk_sa 
    integer :: bcol        
    integer :: local_blk   
    integer :: blk_ind_sa  

    node        = fkeep%bc(blk)%node
    nb          = fkeep%nodes(node)%nb    
    blkm        = fkeep%bc(blk)%blkm
    blk_sa      = fkeep%nodes(node)%blk_sa
    bcol_blk_sa = fkeep%bc(blk_sa)%bcol
    bcol        = fkeep%bc(blk)%bcol
    local_blk   = blk - fkeep%bc(blk)%dblk ! In the bcol
    blk_ind_sa  = nb * (local_blk + (bcol - bcol_blk_sa)) + 1
    p           => fkeep%nodes(node)%index(blk_ind_sa : blk_ind_sa + blkm - 1)

  end subroutine getPointerBlkIndex

  subroutine getSolveNDep(fkeep, node, ind, nind, ndep)
    type(spllt_fkeep), intent(in) :: fkeep
    integer, intent(in)           :: node
    integer, intent(inout)        :: ind(:)
    integer, intent(inout)        :: nind
    integer, intent(inout)        :: ndep(:)

    integer :: nldep, i
    integer :: parent, nparent

    parent = node
    nparent = 0
    do while(parent .lt. fkeep%info%num_nodes)
      nparent = nparent + 1
      parent = fkeep%nodes(parent)%parent
    end do

    if(nparent .eq. 0) then
      ndep(1) = 0
      return
    end if

    parent = node

    do i = 1, nparent
      parent = fkeep%nodes(parent)%parent
      nldep = 0

      if(parent .le. fkeep%info%num_nodes) then
        call reduce_ind_and_get_ndep(fkeep, ind, nind, parent, nldep)
        ndep(i) = nldep
      end if
    end do

  end subroutine getSolveNDep

  subroutine getSolveDep(fkeep, node, ind, nind, dep, ndep)
    type(spllt_fkeep), intent(in) :: fkeep
    integer, intent(in)           :: node
    integer, intent(inout)        :: ind(:)
    integer, intent(inout)        :: nind
    integer, intent(inout)        :: dep(:)
    integer, intent(in)           :: ndep(:)

    integer :: i
    integer :: parent, nparent

    parent = node
    nparent = 0

    do while(parent .lt. fkeep%info%num_nodes)
      nparent = nparent + 1
      parent = fkeep%nodes(parent)%parent
    end do

    parent = node

    do i = 1, nparent
      parent = fkeep%nodes(parent)%parent

      if(parent .le. fkeep%info%num_nodes) then
        call reduce_ind_and_get_dep(fkeep, ind, nind, parent, &
          dep(ndep(i) : ndep(i + 1) - 1))
      end if

    end do

  end subroutine getSolveDep

  subroutine fwd_update_dependency(fkeep, blk, dep)
    use spllt_data_mod

    type(spllt_fkeep), intent(in)     :: fkeep
    integer, intent(in)               :: blk    ! Index of block 
!   integer, pointer,     intent(out) :: dep(:) !List of dependencies
    integer, allocatable, intent(out) :: dep(:) !List of dependencies
    
    integer :: previous_dblk
    integer :: last_previous_dblk
    integer :: diff_bcol
    integer :: diff_previous_bcol
    integer :: node
    integer :: blk_sa, blk_en
    integer :: bcol_blk_sa, bcol
    integer :: blkm, nb, local_blk, offset
    integer :: child_node, i
    integer :: nblk_dep, nchild, nnode_child, nind
    integer :: new_method
    integer, allocatable :: nblk_child(:) ! Remove by using a workspace
    integer, allocatable :: node_child(:) ! Remove by using a workspace
    integer, allocatable :: node_index(:) ! Remove by using a workspace
    integer, allocatable :: node_child_bis(:) ! Remove by using a workspace

    node    = fkeep%bc(blk)%node
    blk_sa  = fkeep%nodes(node)%blk_sa
    blk_en  = fkeep%nodes(node)%blk_en
    bcol_blk_sa = fkeep%bc(blk_sa)%bcol
    bcol = fkeep%bc(blk)%bcol

    nb      = fkeep%nodes(node)%nb    
    blkm    = fkeep%bc(blk)%blkm
    local_blk = blk - fkeep%bc(blk)%dblk
    offset  = nb * ( local_blk + (bcol - bcol_blk_sa)) + 1
    
    new_method = 1

!   print '(a, i3, a, i3)', "Initial dep of blk ", blk,        &
!     " is ", fkeep%bc(blk)%dep_initial
!   print *, "Trying to print from ", offset, " to ", offset + blkm - 1
!   call print_iarray("block row", blkm,                &
!     fkeep%nodes(node)%index(offset: offset + blkm - 1))

!   if(blk .eq. blk_sa) then
!     print '(a, i3, a, i3, a, i3)', "In node ", node, " blk_sa = ",    &
!       blk_sa, " and blk_en ", blk_en
!     print *, "Node index ", fkeep%nodes(node)%index
!     print *, "Children nodes are ", fkeep%nodes(node)%child
!   end if
!       call get_update_dep(fkeep, child_node, node, pos)
!       print *, "This correponds in index of the child node as "
!       call print_iarray("rows in child_node", size(pos),    &
!         fkeep%nodes(node)%index(pos))
!       deallocate(pos)

!   print *, "Get dependencies of blk ", blk

    !If blk belongs to the first block column of the node,
    ! then we consider the node dependencies of the block
    if(fkeep%nodes(node)%blk_sa .eq. fkeep%bc(blk)%dblk) then

      nchild  = node - fkeep%nodes(node)%least_desc
      allocate(nblk_child(nchild + 1), node_child(nchild))
      nblk_child = zero

      nnode_child = 1
      cur_node    = node

      do i = 1, nchild
        node_child(nnode_child : nnode_child + fkeep%nodes(cur_node)%nchild - 1) = fkeep%nodes(cur_node)%child
        nnode_child = nnode_child + fkeep%nodes(cur_node)%nchild
        cur_node = node_child(i)
      end do

      allocate(node_index(size(fkeep%nodes(node)%index)))
      node_index = fkeep%nodes(node)%index

      node_index  = fkeep%nodes(node)%index
      if(new_method .eq. 1) then
        if(nchild .gt. 0) then

          allocate(node_child_bis(nchild + 1))
          node_child_bis    = zero
          node_child_bis(1) = one

          nind  = size(node_index(offset : offset + blkm - 1))
!         print *, "=============== GET number of update for block ", blk

          call getUpdateNDep(fkeep, node, node_index(offset: offset + blkm - 1),&
            nind, node_child_bis(2 : nchild+1))
!         call print_iarray("=====> #dep in NODE_CHILD ", nchild, &
!           node_child_bis(2 : nchild + 1), 1)

          !Restore the array
          node_index = fkeep%nodes(node)%index

          !PostTreatment of ndep to compute the accsum
          do i = 1, nchild
            node_child_bis(i + 1) = node_child_bis(i) + node_child_bis(i + 1)
          end do
!         call print_iarray("PostTreated node_child_bis ", nchild + 1, &
!           node_child_bis, 1)

          if(node_child_bis(nchild + 1) .gt. 1) then
            allocate(dep(node_child_bis(nchild + 1) - 1))

            call getUpdateDep(fkeep, node, node_index(offset : offset + blkm - 1),&
              nind, dep, node_child_bis)
!           print *, "=====> dep of ", blk, " in NODE_CHILD are ", dep

!           deallocate(dep)
          else
            allocate(dep(1))
            dep(1) = blk
          end if
        else
          allocate(dep(1))
          dep(1) = blk
        end if
      else
!     node_index = fkeep%nodes(node)%index

        do i = 1, nchild
  !       child_node = fkeep%nodes(fkeep%nodes(node)%least_desc + i - 1)%num
          child_node = node_child(i)

          call get_update_nblk(fkeep, child_node,                     &
  !         fkeep%nodes(node)%index(offset : offset + blkm - 1),       &
            node_index(offset : offset + blkm - 1),                    &
            nblk_child(i + 1))

!         print *, nblk_child(i + 1), " found in ", child_node

          if(nblk_child(i+1) .gt. 0) then
            nblk_child(i+1) = nblk_child(i+1) + nblk_child(i)
          else
            nblk_child(i+1) = nblk_child(i)
          end if
        end do

!       call print_iarray("nblk_child", nchild + 1, nblk_child)
        node_index = fkeep%nodes(node)%index

        if(nblk_child(nchild+1) .gt. 0) then
          allocate(dep(nblk_child(nchild + 1)))

          do i = 1, nchild
            if(nblk_child(i + 1) .ne. nblk_child(i)) then
  !           child_node = fkeep%nodes(fkeep%nodes(node)%least_desc + i - 1)%num
              child_node = node_child(i)
              call get_update_dep_blk(fkeep, child_node,            &
  !             fkeep%nodes(node)%index(offset : offset + blkm - 1), &
                node_index(offset : offset + blkm - 1), &
                dep(nblk_child(i) + 1 : nblk_child(i+1)))
            end if
          end do

!         print *, "For blk ", blk
!         call print_iarray("Node dependencies found ", size(dep), dep)
        else

          allocate(dep(1))
          dep(1) = blk

  !       call print_iarray("Simulated dependencies ",  &
  !         size(dep), dep)

        end if

        deallocate(nblk_child)
      end if
    else

      allocate(dep(1))

!     if(bcol .gt. bcol_blk_sa) then
      previous_dblk       = fkeep%bc(fkeep%bc(blk)%dblk - 1)%dblk
      last_previous_dblk  = fkeep%bc(previous_dblk)%last_blk
      diff_bcol           = blk - fkeep%bc(blk)%dblk
      diff_previous_bcol  = last_previous_dblk - previous_dblk

      if(last_previous_dblk .gt. (previous_dblk + diff_bcol)) then
        dep(1) = previous_dblk + diff_bcol + 1
      end if
!     end if
!     call print_iarray("Local dependencies ", size(dep), dep)
    end if

!   call print_iarray("Returned dep from fwd_update_dependency",  &
!     size(dep), dep)

  end subroutine fwd_update_dependency

  integer function bwd_update_dependency(fkeep, blk)
    use spllt_data_mod

    type(spllt_fkeep), intent(in)   :: fkeep
    integer, intent(in)             :: blk  ! Index of block 
    
    bwd_update_dependency = blk

    if(fkeep%bc(blk)%last_blk .ne. blk) then
      bwd_update_dependency = blk + 1
    end if

  end function bwd_update_dependency

  integer function fwd_solve_dependency(fkeep, blk)
    use spllt_data_mod

    type(spllt_fkeep), intent(in)   :: fkeep
    integer, intent(in)             :: blk  ! Index of block 

    if(fkeep%bc(blk)%dblk .ne. blk) then
      fwd_solve_dependency = fkeep%bc(blk)%dblk
    else
      fwd_solve_dependency = blk
    end if

  end function fwd_solve_dependency

  subroutine bwd_solve_dependency(fkeep, blk, dep)
    use spllt_data_mod

    type(spllt_fkeep), intent(in)     :: fkeep
    integer, intent(in)               :: blk    ! Index of block 
!   integer, pointer, intent(out)     :: dep(:) !List of dependencies
    integer, allocatable, intent(out) :: dep(:) !List of dependencies

    integer :: offset
    integer :: next_dblk    
    integer :: dist
    integer :: node, parent, max_node, nparent
    integer :: nb, blkm, blk_sa, blk_en, local_blk_sa
    integer :: bcol_blk_en, bcol_blk_sa, bcol, nbcol
    integer :: lblk, nlblk, dblk
    integer, allocatable :: node_parent(:) ! Remove by using a workspace
    integer, allocatable :: node_index(:) ! Remove by using a workspace

    node      = fkeep%bc(blk)%node
    parent    = fkeep%nodes(node)%parent
    max_node  = fkeep%info%num_nodes
    nparent   = max_node - node

    blk_sa      = fkeep%nodes(node)%blk_sa
    blk_en      = fkeep%nodes(node)%blk_en
    bcol_blk_sa = fkeep%bc(blk_sa)%bcol
    bcol_blk_en = fkeep%bc(blk_en)%bcol
    bcol        = fkeep%bc(blk)%bcol
    nbcol       = bcol_blk_en - bcol_blk_sa + 1

    nb      = fkeep%nodes(node)%nb    
    blkm    = fkeep%bc(blk)%blkm
    dblk    = fkeep%bc(blk)%dblk
    local_blk = blk - dblk
    offset  = nb * ( local_blk + (bcol - bcol_blk_sa)) + 1

    lblk = local_blk + bcol - bcol_blk_sa + 1
    nlblk = fkeep%bc(blk_sa)%last_blk - blk_sa + 1

    allocate(node_index(size(fkeep%nodes(node)%index)))
    node_index = fkeep%nodes(node)%index

    !Check if blk belongs to the last bcol of the node
    ! or blk is a diagonal block
    ! or blk belongs to L_{21}, 
    ! where the L_{21} is the off diagonal block of L such that 
    ! L = [L_{11} ; L_{21}], with L_{11} is the triangular diagonal block
    if(bcol .eq. bcol_blk_en  &
      .or. blk .eq. dblk      &
      .or. lblk .gt. nbcol) then
      if(nparent .gt. 0) then

        allocate(node_parent(nparent + 1))
        node_parent    = zero
        node_parent(1) = one

        nind  = size(node_index(offset : offset + blkm - 1))
!       print *, "=============== GET number of update for block ", blk

        call getSolveNDep(fkeep, node, node_index(offset: offset + blkm - 1),&
          nind, node_parent(2 : nparent+1))
       !call print_iarray("=====> #dep in NODE_parent ", nparent, &
       !  node_parent(2 : nparent + 1), 1)

        !Restore the array
        node_index  = fkeep%nodes(node)%index
        nind        = size(node_index(offset : offset + blkm - 1))

        !PostTreatment of ndep to compute the accsum
        do i = 1, nparent
          node_parent(i + 1) = node_parent(i) + node_parent(i + 1)
        end do
       !call print_iarray("PostTreated node_parent_bis ", nparent + 1, &
       !  node_parent, 1)

        if(node_parent(nparent + 1) .gt. 1) then
          allocate(dep(node_parent(nparent + 1) - 1))

          call getSolveDep(fkeep, node, node_index(offset : offset + blkm - 1),&
            nind, dep, node_parent)
!         print *, "=====> dep of ", blk, " in NODE_parent are ", dep

          !       deallocate(dep)
        else
          allocate(dep(1))
          dep(1) = blk
        end if
      else

        allocate(dep(1))

        if(bcol .lt. bcol_blk_en) then
!         print *, "lblk = ", lblk, "/", nlblk
          dep(1) = blk_sa + (lblk - 1) * ( nlblk + 1 - 0.5 * lblk )
!         print *, "dep =====> ", dep(1)
        else
          dep(1) = blk
        end if
      end if
    else

      allocate(dep(1))

      dep(1) = blk_sa + (lblk - 1) * ( nlblk + 1 - 0.5 * lblk )
      
     !dist      = blk - dblk
     !next_dblk = fkeep%bc(blk)%last_blk + 1
     !allocate(dep(1))

     !if(dist .gt. 0) then
     !  dep(1) = next_dblk + dist - 1
     !else
     !  dep(1) = blk
     !end if

    end if

  end subroutine bwd_solve_dependency

! integer function bwd_solve_dependency(fkeep, blk)
!   use spllt_data_mod

!   type(spllt_fkeep), intent(in)   :: fkeep
!   integer, intent(in)             :: blk  ! Index of block 

!   integer :: next_dblk    
!   integer :: dist

!   dist = blk - fkeep%bc(blk)%dblk
!   next_dblk = fkeep%bc(blk)%last_blk + 1

!   if(dist .gt. 0) then
!     bwd_solve_dependency = next_dblk + dist - 1
!   else
!     bwd_solve_dependency = blk
!   end if

! end function bwd_solve_dependency
end module spllt_solve_dep_mod
