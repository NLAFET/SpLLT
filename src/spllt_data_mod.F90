module spllt_data_mod
#if defined(SPLLT_USE_STARPU)
  use iso_c_binding
  use starpu_f_mod
#elif defined(SPLLT_USE_PARSEC)
  use parsec_f08_interfaces
#endif
  ! use hsl_zd11_double
  implicit none

  integer, parameter :: wp = kind(0d0)
#if defined(SPLLT_USE_STARPU) || defined(SPLLT_USE_PARSEC) 
  integer, parameter :: long = c_long
#else
  integer, parameter :: long = selected_int_kind(18)
#endif

  real(wp), parameter :: one = 1.0_wp
  real(wp), parameter :: zero = 0.0_wp

  ! error flags
  integer, parameter :: spllt_success           = 0 
  integer, parameter :: spllt_error_allocation  = -1
  integer, parameter :: spllt_error_unknown     = -99 

  ! Default values
  ! node amalgamation parameter
  integer, parameter :: spllt_nemin_default = 32
  ! Block size with dense kernel
  integer, parameter :: spllt_nb_default = 256

#if defined(SPLLT_USE_OMP) && defined(SPLLT_OMP_TRACE) 
  integer, save :: ini_nde_id, fac_blk_id, slv_blk_id, upd_blk_id, upd_btw_id 
#endif

#if defined(SPLLT_USE_PARSEC)
  type(parsec_context_t) :: ctx
  integer(c_int)        :: nds
  integer(c_int)        :: rank
#endif

  !*************************************************
  
  ! Data type for storing information for each block (BLK)
  ! The blocks are numbered 1,2,..., keep%final_blk
  type block_type
     ! Static info, which is set in ma87_analayse
     integer :: bcol            ! block column that blk belongs to
     integer :: blkm            ! height of block (number of rows in blk)
     integer :: blkn            ! width of block (number of columns in blk)
     integer(long) :: dblk      ! id of the block on the diagonal within the 
     ! block column to which blk belongs
     integer :: dep_initial     ! initial dependency count for block,
     integer(long) :: id        ! The block identitifier (ie, its number blk)
     integer(long) :: last_blk  ! id of the last block within the
     ! block column to which blk belongs
     integer :: node            ! node to which blk belongs
     integer :: sa              ! posn of the first entry of the
     ! block blk within the array that holds the block column of L
     ! that blk belongs to.

     ! Non-static info
     integer :: dep  ! dependency countdown/marker. Once factor or solve done,
     ! value is -2.
     ! for this block.
     ! Note: locks initialised in ma87_analyse and destroyed
     !       in ma87_finalise
  end type block_type

  !*************************************************

  ! Derived type for holding data for each node.
  ! This information is set up by ma87_analyse once the assembly tree
  ! has been constructed.
  type node_type
     integer(long) :: blk_sa ! identifier of the first block in node
     integer(long) :: blk_en ! identifier of the last block in node

     integer :: nb ! Block size for nodal matrix
     ! If number of cols nc in nodal matrix is less than control%nb but 
     ! number of rows is large, the block size for the node is taken as 
     ! control%nb**2/nc, rounded up to a multiple of 8. The aim is for
     ! the numbers of entries in the blocks to be similar to those in the 
     ! normal case. 

     integer :: sa ! index (in pivotal order) of the first column of the node
     integer :: en ! index (in pivotal order) of the last column of the node

     integer, allocatable :: index(:) ! holds the permuted variable
     ! list for node. They are sorted into increasing order.
     ! index is set up by ma87_analyse

     integer :: nchild ! number of children node has in assembly tree
     integer, allocatable :: child(:) ! holds children of node
     integer :: parent ! Parent of node in assembly tree
     integer :: least_desc ! Least descendant in assembly tree

  end type node_type

  ! user control
  type spllt_cntl
     integer :: ncpu = 1 ! number of CPU workers
     integer :: nb   = 16 ! blocking size
     integer :: nemin = 32 ! node amalgamation parameter
     logical :: prune_tree = .false.
     integer :: min_width_blas  = 8      ! Minimum width of source block
     ! integer :: min_width_blas  = 0      ! Minimum width of source block
     ! before we use an indirect update_between
  end type spllt_cntl

  ! useful type for representing dependencies betwewen blocks

  ! input dependency
  type spllt_dep_upd_in
     integer(long) :: id_jk = 0
     integer :: p1 = 0
     integer(long) :: id_ik = 0
     integer :: p2 = 0
     integer :: csrc = 0 ! first row in Ljk
     integer :: rsrc = 0 ! first row in Lik
     logical :: sync = .true.
  end type spllt_dep_upd_in

  ! input dependency
  type spllt_dep_upd_out
     integer :: flow = 0 ! 1 -> ljk and 2 -> ljk  
     integer(long) :: id_ij = 0
     integer :: p = 0
  end type spllt_dep_upd_out

  ! block type  
  type spllt_bc_type
     type(block_type), pointer :: blk => null()! pointer to the block in keep
     real(wp), pointer :: c(:)
#if defined(SPLLT_USE_STARPU)
     type(c_ptr)    :: hdl  ! StarPU handle
     type(c_ptr)    :: hdl2  ! DEBUG
#endif
     integer :: mem_node = 0 ! memory node where the block is allocated
     

#if defined(SPLLT_USE_PARSEC)
     ! store ids of blocks contributing to this block
     ! type(spllt_dep_list), pointer :: dep_in  => null()
     type(spllt_dep_upd_in), pointer :: dep_in(:)  => null()
     ! store ids of blocks for which this block contributes to 
     ! type(spllt_dep_list), pointer :: dep_out => null()
     type(spllt_dep_upd_out), pointer :: dep_out(:) => null()
#endif
  end type spllt_bc_type

  ! node type
  type spllt_node_type
     type(node_type), pointer :: node
     integer :: num ! node id
#if defined(SPLLT_USE_STARPU)
     type(c_ptr)    :: hdl  ! StarPU handle
     type(c_ptr)    :: hdl2  ! StarPU second handle
#endif
     type(spllt_bc_type) :: buffer ! buffer for accumulating updates
  end type spllt_node_type

  type spllt_workspace_i
     integer, pointer :: c(:)
#if defined(SPLLT_USE_STARPU)
     type(c_ptr)    :: hdl  ! StarPU handle
#endif
  end type spllt_workspace_i

  ! problem data (analyis)
  type spllt_adata_type
     integer :: nnodes
     integer :: n
     integer(long) :: num_factor = 0_long ! Number of entries in the factor.
     integer(long) :: num_flops = 0_long  ! Number of flops for factor.
     ! weight(i): weight of the subtree rooted at node i where weight
     ! corresponds to the number of flops
     integer(long), allocatable :: weight(:)
     integer, allocatable :: small(:)
  end type spllt_adata_type

  ! problem data (factorization)
  type spllt_data_type
     type(spllt_bc_type), allocatable :: bc(:) ! blocks
#if defined(SPLLT_USE_OMP)
     type(spllt_bc_type), allocatable :: workspace(:) ! workspaces
#else
     type(spllt_bc_type) :: workspace ! workspaces
#endif
     type(spllt_node_type), allocatable :: nodes(:) ! super nodes 
#if defined(SPLLT_USE_PARSEC)
     ! ids of diag blocks. size keep%nbcol
     integer(long), allocatable :: diags(:)
     ! data descriptor
     type(c_ptr) :: ddesc
#endif

#if defined(SPLLT_USE_OMP)
     type(spllt_workspace_i), allocatable :: row_list(:), col_list(:) ! workspaces
#else
     type(spllt_workspace_i) :: row_list, col_list ! workspaces
#endif

#if defined(SPLLT_USE_OMP)
     type(spllt_workspace_i), allocatable :: map(:)
#else
     type(spllt_workspace_i) :: map ! workspaces
#endif
  end type spllt_data_type

  type spllt_options
     integer :: ncpu = 1              ! number of CPU workers
     integer :: nb   = 16             ! blocking size
     character(len=100) :: mat = ''
     integer :: nemin = -1            ! nemin parameter for analysis
     logical :: prune_tree = .false.  ! use tree pruning
     character(len=3) :: fmt='csc'
  end type spllt_options

end module spllt_data_mod
