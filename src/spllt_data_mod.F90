module spllt_data_mod
#if defined(SPLLT_USE_STARPU)
  use, intrinsic :: iso_c_binding
  use starpu_f_mod
#elif defined(SPLLT_USE_PARSEC)
  use parsec_f08_interfaces
#endif
  implicit none

  integer, parameter :: wp = kind(0d0)
#if defined(SPLLT_USE_STARPU) || defined(SPLLT_USE_PARSEC) 
  integer, parameter :: long = c_long
#else
  integer, parameter :: long = selected_int_kind(18)
#endif

  real(wp), parameter :: one = 1.0_wp
  real(wp), parameter :: zero = 0.0_wp

  ! Error flags
  integer, parameter :: SPLLT_SUCCESS              = 0 
  integer, parameter :: SPLLT_ERROR_ALLOCATION     = -1
  integer, parameter :: SPLLT_ERROR_UNIMPLEMENTED  = -98
  integer, parameter :: SPLLT_ERROR_UNKNOWN        = -99 

  ! Default values
  integer, parameter :: nemin_default = 32 ! node amalgamation parameter
  integer, parameter :: nb_default = 256 ! block size with dense kernel

#if defined(SPLLT_USE_OMP) && defined(SPLLT_OMP_TRACE) 
  integer, save :: ini_nde_id, fac_blk_id, slv_blk_id, upd_blk_id, upd_btw_id 
#endif

#if defined(SPLLT_USE_PARSEC)
  type(parsec_context_t) :: ctx
  integer(c_int) :: nds
  integer(c_int) :: rank
#endif

  !*************************************************
  !  
  ! Data type for storing information for each block (BLK)
  ! The blocks are numbered 1,2,..., keep%final_blk
  type block_type
     ! Static info, which is set in ma87_analayse
     integer :: bcol            ! block column that blk belongs to
     integer :: blkm            ! height of block (number of rows in blk)
     integer :: blkn            ! width of block (number of columns in blk)
     integer(long) :: dblk      ! id of the block on the diagonal within the 
     ! block column to which blk belongs
     integer :: dep_initial     ! initial dependency count for block,
     integer(long) :: id        ! The block identitifier (ie, its number blk)
     integer(long) :: last_blk  ! id of the last block within the
     ! block column to which blk belongs
     integer :: node            ! node to which blk belongs
     integer :: sa              ! posn of the first entry of the
     ! block blk within the array that holds the block column of L
     ! that blk belongs to.

     ! Non-static info
     integer :: dep  ! dependency countdown/marker. Once factor or solve done,
     ! value is -2.
     ! for this block.
     ! Note: locks initialised in ma87_analyse and destroyed
     !       in ma87_finalise
  end type block_type

  ! !*************************************************
  ! !
  ! ! Derived type for holding data for each node.
  ! ! This information is set up by ma87_analyse once the assembly tree
  ! ! has been constructed.
  ! type node_type
  !    integer(long) :: blk_sa ! identifier of the first block in node
  !    integer(long) :: blk_en ! identifier of the last block in node

  !    integer :: nb ! Block size for nodal matrix
  !    ! If number of cols nc in nodal matrix is less than control%nb but 
  !    ! number of rows is large, the block size for the node is taken as 
  !    ! control%nb**2/nc, rounded up to a multiple of 8. The aim is for
  !    ! the numbers of entries in the blocks to be similar to those in the 
  !    ! normal case. 

  !    integer :: sa ! index (in pivotal order) of the first column of the node
  !    integer :: en ! index (in pivotal order) of the last column of the node

  !    integer, allocatable :: index(:) ! holds the permuted variable
  !    ! list for node. They are sorted into increasing order.
  !    ! index is set up by ma87_analyse

  !    integer :: nchild ! number of children node has in assembly tree
  !    integer, allocatable :: child(:) ! holds children of node
  !    integer :: parent ! Parent of node in assembly tree
  !    integer :: least_desc ! Least descendant in assembly tree

  ! end type node_type

  ! user control
  type spllt_cntl
     integer :: ncpu = 1 ! number of CPU workers
     integer :: nb   = 16 ! blocking size
     integer :: nemin = 32 ! node amalgamation parameter
     logical :: prune_tree = .false.
     integer :: min_width_blas  = 8      ! Minimum width of source block
     ! integer :: min_width_blas  = 0      ! Minimum width of source block
     ! before we use an indirect update_between
  end type spllt_cntl

  ! useful type for representing dependencies betwewen blocks

  ! input dependency
  type spllt_dep_upd_in
     integer(long) :: id_jk = 0
     integer :: p1 = 0
     integer(long) :: id_ik = 0
     integer :: p2 = 0
     integer :: csrc = 0 ! first row in Ljk
     integer :: rsrc = 0 ! first row in Lik
     logical :: sync = .true.
  end type spllt_dep_upd_in

  ! input dependency
  type spllt_dep_upd_out
     integer :: flow = 0 ! 1 -> ljk and 2 -> ljk  
     integer(long) :: id_ij = 0
     integer :: p = 0
  end type spllt_dep_upd_out

  ! block type  
  type spllt_bc_type
     type(block_type), pointer :: blk => null()! pointer to the block in keep
     real(wp), pointer :: c(:)
#if defined(SPLLT_USE_STARPU)
     type(c_ptr)    :: hdl  ! StarPU handle
     type(c_ptr)    :: hdl2  ! DEBUG
#endif
     integer :: mem_node = 0 ! memory node where the block is allocated
     

#if defined(SPLLT_USE_PARSEC)
     ! store ids of blocks contributing to this block
     ! type(spllt_dep_list), pointer :: dep_in  => null()
     type(spllt_dep_upd_in), pointer :: dep_in(:)  => null()
     ! store ids of blocks for which this block contributes to 
     ! type(spllt_dep_list), pointer :: dep_out => null()
     type(spllt_dep_upd_out), pointer :: dep_out(:) => null()
#endif
  end type spllt_bc_type

  ! node type
  type spllt_node_type
     ! type(node_type), pointer :: node
     integer :: num ! node id
#if defined(SPLLT_USE_STARPU)
     type(c_ptr)    :: hdl  ! StarPU handle
     type(c_ptr)    :: hdl2  ! StarPU second handle
#endif
     type(spllt_bc_type) :: buffer ! buffer for accumulating updates

     integer(long) :: blk_sa ! identifier of the first block in node
     integer(long) :: blk_en ! identifier of the last block in node

     integer :: nb ! Block size for nodal matrix
     ! If number of cols nc in nodal matrix is less than control%nb but 
     ! number of rows is large, the block size for the node is taken as 
     ! control%nb**2/nc, rounded up to a multiple of 8. The aim is for
     ! the numbers of entries in the blocks to be similar to those in the 
     ! normal case. 

     integer :: sa ! index (in pivotal order) of the first column of the node
     integer :: en ! index (in pivotal order) of the last column of the node

     integer, allocatable :: index(:) ! holds the permuted variable
     ! list for node. They are sorted into increasing order.
     ! index is set up by ma87_analyse

     integer :: nchild ! number of children node has in assembly tree
     integer, allocatable :: child(:) ! holds children of node
     integer :: parent ! Parent of node in assembly tree
     integer :: least_desc ! Least descendant in assembly tree
  end type spllt_node_type

  type spllt_workspace_i
     integer, pointer :: c(:)
#if defined(SPLLT_USE_STARPU)
     type(c_ptr)    :: hdl  ! StarPU handle
#endif
  end type spllt_workspace_i

  !*************************************************
  !
  ! Data associated with input matrix know after analysis phase
  type spllt_adata_type
     integer :: nnodes
     integer :: n
     integer(long) :: num_factor = 0_long ! Number of entries in the factor.
     integer(long) :: num_flops = 0_long  ! Number of flops for factor.
     ! weight(i): weight of the subtree rooted at node i where weight
     ! corresponds to the number of flops
     integer(long), allocatable :: weight(:)
     integer, allocatable :: small(:)
  end type spllt_adata_type


  type spllt_options
     integer :: ncpu = 1              ! number of CPU workers
     integer :: nb   = 16             ! blocking size
     character(len=100) :: mat = ''
     integer :: nemin = -1            ! nemin parameter for analysis
     logical :: prune_tree = .false.  ! use tree pruning
     character(len=3) :: fmt='csc'
  end type spllt_options

  !*************************************************
  !
  ! data type for returning information to user.
  type spllt_info 
     integer :: flag = SPLLT_SUCCESS  ! error return flag (0 on success)
     integer :: maxdepth = 0           ! maximum depth of the tree.
     integer(long) :: num_factor = 0_long ! number of entries in the factor.
     integer(long) :: num_flops = 0_long  ! number of flops for factor.
     integer :: num_nodes = 0          ! number of nodes
     integer :: stat = 0               ! STAT value on error return -1.
  end type Spllt_info


  !*************************************************  
  !
  ! Data type that represents a single block column in L
  ! (allocated by ma87_analyse)
  type lfactor
     real(wp), dimension(:), allocatable :: lcol ! holds block column
  end type lfactor

  !*************************************************  
  ! Data type for storing mapping from user's matrix values into
  ! block columns of L
  type lmap_type
     integer(long) :: len_map ! length of map
     integer(long), allocatable :: map(:,:) ! holds map from user's val
     ! array into lfact(:)%lcol values as follows:
     ! lcol( map(1,i) ) += val( map(2,i) )     i = 1:lmap
     ! map is set at end of analyse phase using subroutines make_map
     ! and lcol_map, and is used in factorization phase by blk_col_add_a
  end type lmap_type

  ! problem data (factorization)
  type spllt_fdata_type
     type(spllt_bc_type), allocatable :: bc(:) ! blocks
#if defined(SPLLT_USE_OMP)
     type(spllt_bc_type), allocatable :: workspace(:) ! workspaces
#else
     type(spllt_bc_type) :: workspace ! workspaces
#endif
     type(spllt_node_type), allocatable :: nodes(:) ! supernodes 
#if defined(SPLLT_USE_PARSEC)
     ! ids of diag blocks. size keep%nbcol
     integer(long), allocatable :: diags(:)
     ! data descriptor
     type(c_ptr) :: ddesc
#endif

#if defined(SPLLT_USE_OMP)
     type(spllt_workspace_i), allocatable :: row_list(:), col_list(:) ! workspaces
#else
     type(spllt_workspace_i) :: row_list, col_list ! workspaces
#endif

#if defined(SPLLT_USE_OMP)
     type(spllt_workspace_i), allocatable :: map(:)
#else
     type(spllt_workspace_i) :: map ! workspaces
#endif
     !     private
     type(block_type), dimension(:), allocatable :: blocks ! block info
     integer, dimension(:), allocatable :: flag_array ! allocated to
     ! have size equal to the number of threads. For each thread, holds
     ! error flag
     integer(long) :: final_blk = 0 ! Number of blocks. Used for destroying
     ! locks in finalise
     type(spllt_info) :: info ! Holds copy of info
     integer :: maxmn ! holds largest block dimension
     integer :: n  ! Order of the system.
     ! type(node_type), dimension(:), allocatable :: nodes ! nodal info
     integer :: nbcol = 0 ! number of block columns in L
     type(lfactor), dimension(:), allocatable :: lfact
     ! holds block cols of L
     type(lmap_type), dimension(:), allocatable :: lmap
     ! holds mapping from matrix values into lfact
  end type spllt_fdata_type

  ! !*************************************************  
  ! ! Data type for communication between threads and routines
  ! type spllt_keep
  !    !     private
  !    type(block_type), dimension(:), allocatable :: blocks ! block info
  !    integer, dimension(:), allocatable :: flag_array ! allocated to
  !    ! have size equal to the number of threads. For each thread, holds
  !    ! error flag
  !    integer(long) :: final_blk = 0 ! Number of blocks. Used for destroying
  !    ! locks in finalise
  !    type(spllt_info) :: info ! Holds copy of info
  !    integer :: maxmn ! holds largest block dimension
  !    integer :: n  ! Order of the system.
  !    type(node_type), dimension(:), allocatable :: nodes ! nodal info
  !    integer :: nbcol = 0 ! number of block columns in L
  !    type(lfactor), dimension(:), allocatable :: lfact
  !    ! holds block cols of L
  !    type(lmap_type), dimension(:), allocatable :: lmap
  !    ! holds mapping from matrix values into lfact
  ! end type spllt_keep

  !*************************************************
  !  
!   ! Data type for user controls
!   type spllt_control

!      integer :: diagnostics_level = 0      ! Controls diagnostic printing.
!      ! Possible values are:
!      !  < 0: no printing.
!      !    0: error and warning messages only.
!      !    1: as 0 plus basic diagnostic printing.
!      !    2: as 1 plus some more detailed diagnostic messages.
!      !    3: as 2 plus all entries of user-supplied arrays.
!      integer :: nb    = spllt_nb_default ! Controls the size of the
!      ! blocks used within each node (used to set nb within node_type)
!      integer :: nemin = spllt_nemin_default    
!      ! Node amalgamation parameter. A child node is merged with its parent 
!      ! if they both involve fewer than nemin eliminations.
!      integer :: unit_diagnostics = 6    ! unit for diagnostic messages
!      ! Printing is suppressed if unit_diagnostics  <  0.
!      integer :: unit_error       = 6    ! unit for error messages
!      ! Printing is suppressed if unit_error  <  0.
!      integer :: unit_warning     = 6    ! unit for warning messages
!      ! Printing is suppressed if unit_warning  <  0.


! !!!! Undocumented
!      !**   integer :: time_out        = -1     ! If >= 0 some internal timings
!      !**      are printed on unit time_out. For HSL 2011 these are commented
!      !**      using comments !** so easy to search and uncomment
!      !%%%  integer :: unit_log        = -1     ! For profiling log output
!      !%%%     commented out for HSL 2011 using !%%%
!      !%%%  integer :: log_level       = 1      ! Level of profiling information
! !!! Note: commenting out use of time_out and unit_log means
!      !%%%     commented out for HSL 2011 using !%%%

!      integer :: min_width_blas  = 8      ! Minimum width of source block
!      ! before we use an indirect update_between

!   end type spllt_control

contains

  !*************************************************  
  !
  ! Returns the destination block of an internal update task.
  ! Called by add_updates.
  
  integer(long) function get_dest_block(src1, src2)

    type(block_type), intent(in) :: src1
    type(block_type), intent(in) :: src2

    integer(long) :: i
    integer :: sz

    ! Move to diagonal block of target column
    ! sz is the number of (row) blocks in src1
    sz = src1%last_blk - src1%dblk + 1 
    get_dest_block = src1%dblk
    do i = src1%dblk+1, src1%id
       get_dest_block = get_dest_block + sz
       sz = sz - 1
    end do

    ! Move to relevant row block in target col.
    get_dest_block = get_dest_block + src2%id - src1%id

  end function get_dest_block

end module spllt_data_mod
